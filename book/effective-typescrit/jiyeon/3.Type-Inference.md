# 3장 타입 추론

타입스크립트는 타입 추론을 적극적으로 수행합니다. 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여주기 때문에, 코드의 전체적인 안정성이 향상됩니다.
숙련된 타입스크립트 개발자는 비교적 적은 수의 구문(그러나 중요한 부분에는 사용)을 사용합니다. 반면, 초보자의 코드는 불필요한 타입 구문으로 도배되어 있을 겁니다.

## 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입스크립트를 처음 접한 개발자가 자바스크립트 코드를 포팅할 때 가장 먼저 하는 일은 타입 구문을 넣는 것입니다. 그러나 타입스크립트의 많은 타입 구문은 사실 불필요 합니다.

```
// 1번
let x: number = 12;
// 2번
let x = 12;
```

2번처럼만 해도 충분합니다. 편집기에서 x에 마우스를 올려보면 타입이 이미 number로 추론되어 있음을 알 수 있습니다.
만약 타입을 확신하지 못한다면 편집기를 통해 체크하면 됩니다. 타입스크립트는 더 복잡한 객체도 추론할 수 있습니다.

```
const person:{
  name: string,
  born: {
    where: string,
    when: string
  }
  }={
    name: 'Dal Um',
    born: {
      where: 'Yeoju',
      when: 'undefined'
    }
  };
const person={  //타입을 생략하고 다음처럼 작성해도 충분합니다.
  name: 'Dal Um',
  born: {
    where: 'Yeoju',
    when: 'undefined'
  }
};
```

비구조화 할당문은 모든 지역변수의 타입이 추론되도록 합니다. 여기에 추가로 명시적 타입 구문을 넣는다면 불필요한 타입 선언으로 인해 코드가 번잡해 집니다.

```
function logProduct(product: Product){
  const {id, name, price} = product;
  console.loG(id, name, price);
}
```

어떤 언어들은 매개변수의 최종 사용처까지 참고하여 타입을 추론하지만, 타입스크립트는 최종 사용처까지 고려하지 않습니다. 타입스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정됩니다.

이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않습니다. 보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론됩니다.

```
// 이렇게 하지 맙시다.
app.get('/health',(request: express.Request, response: express.Response)=>{resoponse.send('OK');
});
// 이렇게 합시다.
app.get('/health',(request, response)=>{resoponse.send('OK');
});
```

마찬가지로 함수의 반환에도 타입을 명시하여 오류를 방지할 수 있습니다. 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않습니다.

오류의 위치를 제대로 표시해 주는 이점 외에도, 반환타입을 명시해야 하는 이유가 두가지 더 있습니다.

1. 반환타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있습니다.
2. 명명된 타입을 사용하기 위해서 -> 더 직관적인 표현이 됩니다.

```
interface Vector2D{ x: number, y: number}
function add(a: Vector2D, b: Vector2D){
  return {x: a.x + b.x, y: a.y + b.y}
}
```

이 경우 Vector2D와 호환되지만, 입력이 Vector2D인데 반해 출력은 Vector2D가 아니기 때문에 사용자 입장에서는 당황스러울 수 있습니다.

## 아이템 20. 다른 타입에는 다른 변수 사용하기

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 됩니다. 그렇지만 타입스크립트는 곤란해요.

```
//javascript
let id = '12-34-56';
fetchProduct(id);
id = 123456;
fetchProductByNumber(id);

//typescript
let id = '12-34-56';
fetchProduct(id);
id = 123456; // ~~ error 12345 형식은 'string' 형식에 할당할 수 없습니다.
fetchProductByNumber(id); // ~~error

```

여기서 '변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다'는 중요한 관점을 알 수 있습니다. 타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것인데, 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것입니다.

```
let id : string| number = '12-34-56';
```

string과 number를 모두 포함할 수 있도록 확장하면 됩니다. 유니온(union) 타입이라고도 합니다. 하지만 유니온 타입으로 코드가 동작하기는 하지만 더 많은 문제가 생길 수 있습니다. id를 사용할 때마다 값이 어떤 타입인지 확인해야 하기 때문에 더 다루기 어렵습니다.

차라리 별도의 변수를 도입하는 것이 낫습니다. 다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유는 다음과 같습니다.

- 서로 관련이 없는 두 개의 값을 분리
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해 진다.
- 타입이 좀 더 간결
- let 대신 const 변수를 선언 -> 타입 체커가 타입을 추론하기에도 좋다.

## 아이템 21. 타입 넓히기

타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 '가능한' 값들의 집합인 타입을 가집니다. 상수를 사용해서 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 합니다. 이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻입니다. 타입스크립트에서는 이러한 과정을 'widening 넓히기' 라고 부릅니다.

```
interface Vector3 {x: number, y: number, z: number};
function getComponent(vector: Vector3, axis: 'x'|'y'|'z'){
  return vector[axis];
}

let x = 'x';
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);   // ~~error string 형식의 인수는 'x'|'y'|'z' 할당 할 수 없다
```

getComponent 함수는 두 번째 매개변수에 'x'|'y'|'z' 타입을 기대했지만, x의 타입은 할당 시점에 넓히기가 동작해서 string으로 추론되었습니다.
이 넓히기 과정을 제어할 수 있는 첫번째 방법은 const입니다. 만약 let 대신 const로 변수를 선언하면 더 좁은 타입이 됩니다. 실제로 const를 사용하면 위의 예제에서 발생한 오류는 해결이 됩니다.

그러나 const가 만능은 아닙니다. const mixed = ['x',1] 이 예제는 배열에 대한 문제를 보여줍니다. 튜플 타입을 추론해야 할지 어떤 타입으로 추론해야 할지 알 수 없습니다. 비슷한 문제가 객체에서도 발생합니다. 객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룹니다. 그리고 객체의 다른 속성을 추가하지 못하기 때문에 한번에 만들어야 합니다.(자세한 내용은 아이템 23 참고!)

타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의 해야 합니다. 재정의 하는 세 가지 방법이 있습니다.

1. 명시적 타입 구문을 제공하는 것

```
const v: {x: 1|3|5} = {x: 1};
```

2. 타입 체커에 추가적인 문맥을 제공 -> 아이템26에서 자세하게 다룸
3. const 단언문 사용

```
const v1 = {x : 1, y: 2}; // 타입은 {x: number, y: number}
const v2 = {x: 1 as const, y:2} // 타입은 {x: 1, y: number}
const v3 = {x:1, y: 2} as const; // 타입은 {readonly x: 1, y: 2}
```

배열을 튜플 타입으로 추론할 때에서 as const를 사용할 수 있습니다.

넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 const 단언문을 추가하는 것을 고려해야 합니다.
