# 1. frogRiverOne 접근 방법

일단, 문제자체가 이해가 잘 가지 않았다. 그래서 접근방법을 처음에는

1. 리스트의 맥스값을 찾아서 인덱스를 리턴하면 된다고 생각했다.
2. 0프로 뜨는거 보고, 뭐가 문제일까 생각하다가 코드를 줄여보고, return -1만 추가해줬다.
3. 아 이게 아니구나를 깨닫고, 다른 사람풀이를 참고했는데, 왜 return 6인지가 이해가 계속 안됐던.. 왜 set을 쓴거지? 의심도 안했다가 중복을 제거하면 6번째 인덱스임을 이해했던 문제였다.

# 2. permCheck 접근 방법

순열인지 아닌지를 묻는 문제. 아래의 경우 A1은 순열이기 때문에 1을 리턴, 아닌 경우 0을 리턴하면 된다.

```
A1 = [4,2,3,1];
A2 = [1,3,4];
```

1. A의 길이만큼의 배열하나를 만들었다. 값은 1부터 인덱스값으로 초기화
2. A가 순열이라면 A의 총 값과 새로운 배열의 합과 같을 거라고 생각
3. 같으면 1을 틀리면 0을 리턴하도록 했다 ->75%의 답안
4. A[0]번째가 1이 아닐 경우, 순열이 아니라고 판단 0을 리턴하도록 조건문을 추가 -> 83%
5. A 배열이 중복일 수도 있어서, set으로 중복을 확인해보고 중복이라면 0을 리턴하도록 한다 -> 100% 하지만 코드가 지저분하다 조금 더 이쁘게 수정해야한다

# 3. maxCounter 접근 방법

문제를 이해하는것 조차 너무 어려웠던 문제다.
문제는 N의 크키의 값이 0인 배열을 생성하고, A길이의 반복문을 돌면서 A의 값이 N보다 작으면 N의 A번째의 값을 +1 시켜주고, 크다면 N의 배열의 값중 큰값으로 전체 값을 수정해주는 문제다. 나의 접근방법은 아래와 같다.

1. N사이즈의 배열을 하나 생성하고, 초기값을 0으로 해준다
2. A 배열을 돌면서 값이 N보다 작으면 해당하는 1번의 배열 index에 +1을 증가해준다.
3. 사이즈가 크다면 배열에 있는 값들중 큰값으로 전체 초기화
4. 그리고 다시 2번을 진행한다.

44%의 답은, correct 75%, performance 20%으로 나왔다.

fill로 최대값을 채워주는 부분에서 성능이 떨어지는것 같았다.
fill부분을 따로 분리하기 위해 maxToSet이라는 변수를 하나 더 만들었다.

- N의 값보다 클 경우, max값을 maxToSet에 넣어주고, 그 다음부터 maxToSet에 +1 시켜주기 위해 필요하다고 이해했다. (설명이 좋지 못하네요 ..좀 더 설명을 잘 해보도록 고민해볼게요.)
  그리고 fill부분을 map으로 따로 돌려주니 런타임아웃이 나오지 않았다.
  퍼포먼스를 위해 참고한 [https://gist.github.com/jeanlescure/98542e1b40339445acc1]
