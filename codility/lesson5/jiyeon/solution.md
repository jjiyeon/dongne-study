# 1. passingCars 문제

문제를 이해를 했지만, 조합으로 이해했던 부분인데 막상 코드로 구현하려니 어려웠고, 조합 알고리즘을 사용해보고 싶었으나 성능을 통과 못할거란 판단.
다른 이의 풀이를 참고 했던 부분.. prefix sum 이란 주제의 알고리즘은 구간합 알고리즘으로 많은 문제들이 있으나, 이런 문제를 보고 구간합을 떠올리기 위해서 더 훈련이 필요한것 같다.

### 이해한 부분

동쪽 east변수와 count 변수를 선언, A 배열에서 i가 0이면 east 변수를 ++ 해주고, 1이 나오면 count를 east값과 더해준다.

# 2. countDiv

역시, 쉬워보이지만 생각한대로만 코딩하면 퍼포먼스가 딸리는 문제..쉬운 문제일수록 한번 더 생각해봐야 하는것 같다. 반복문을 사용하면 안되는 문제이기 때문에, 오히려 좀 더 유연한 사고가 필요하다. 이런게 더 어려운듯..

1. 처음에는 이해한대로 반복문을 사용해서 갯수를 세어보았는데, 문법적으로나 성능상 좋지 못하다
2. B의 범위에서 K로 나눈값을 A범위에서 K로 나눈값을 빼고, 중복으로 A에서 빠지는 부분을 추가로 더해준다.

더 짧은 코드가 있었지만, 직관적으로 이해하기 쉬운 코드를 참고했다.
[https://sustainable-dev.tistory.com/12]

# 3. genomicRangeQuery

문제를 이해한대로 코딩하면 63%가 나오는데, 퍼포먼스에서 걸리는것 같다. 먼저 이해한대로 구현한 방법은

1. 영향계수를 dna와 key value로 이뤄진 객체를 만든다
2. S 문자열에서 P - Q 인덱스까지 뽑아낸 배열을 만든다
3. 2번에서 뽑은 배열의 사이즈만큼 돌면서, dna의 value의 최소값을 결과변수에 넣어주고 리턴해주는 방법을 생각했다.

퍼포먼스를 올리기 위해 includes로 찾아서 바로 결과값에 push했는데, 통과됐다. 초반에 너무 어렵게 생각한것 같다.

# 4. minAvgTwoSlice

아직 여러 문제를 많이 접하지 않아서 일까 문제가 이해가 갔지만, 코드로 어떻게 풀어야 할지 몰랐던 문제다. 그래서 문제 이해 후, 풀이는 검색을 해봤다. slice가 2또는 3개인 경우만 고려하면 된다고 한다. 평균의 성질로 부분집합의 평균은 가장 작은 인자보다 항상 크다고. 그래서 풀이 코드에서 2개의 합과 3개의 합만 조건으로 둔다.
