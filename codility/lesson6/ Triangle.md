중복되지 않는 인덱스 3가지를 선택하고, 2가지 인덱스 값의 합이 나머지 1가지의 인덱스 값보다 모두 큰 경우가 존재하는지 찾는 문제입니다. 예제로 주어진 케이스는 A[0] = 10, A[2] = 5, A[4] = 8 인 경우인데,

10 + 5 > 8 (참) // A[P] + A[Q] > A[R]<br/>
5 + 8 > 10 (참) // A[Q] + A[R] > A[P]<br/>
8 + 10 > 5 (참) // A[R] + A[P] > A[Q]<br/>
세가지 경우가 문제에 내용을 만족하는 참입니다. <br/>
<br/>

이런 경우의 배열이라면 1을 반환하고, 아니라면 0을 반환해야 합니다.

풀이에 핵심은 배열을 정렬한 상태에서 인접한 세개의 인덱스간의 비교만 진행하면 됩니다.

(그리고 인덱스에 대한 대소조건을 보면, 인덱스를 고려해야 할 것 같지만, 실제로 인덱스는 중복되지만 않으면 괜찮습니다.)

즉, 주어진 예제의 배열을 정리하면 1, 2, 5, 8, 10, 20으로 정렬되고, 인접한 세개의 인덱스간의 조건을 충족하는지 확인합니다.

다시 말해 비교해봐야 하는 경우는

<b>1, 2, 5,</b> 8, 10, 20

1, <b>2, 5, 8,</b> 10, 20

1, 2, <b>5, 8, 10,</b> 20

1, 2, 5, <b>8, 10, 20</b>

와 같이 4가지 경우입니다.

그리고 4가지 경우에서 문제에 조건을 만족하는 경우는 1, 2, 5, 8, 10, 20가 있습니다.

그런데 이미 배열이 정렬되어 있기 때문에, 세가지 경우를 모두 확인하지 않고, 작은 인덱스 2개의 합과 나머지 큰 인덱스의 값만 비교하면 됩니다.

5 + 8 > 10 인 경우가 참이라면, 나머지 경우는 당연히 참일수 밖에 없습니다.

👉 참고 블로그 : https://siyoon210.tistory.com/128

---

```
function solution(A) {
  A.sort((a, b) => a - b);

  for (let i = 0; i < A.length; i++) {
    if (A[i] + A[i + 1] > A[i+2]) return 1;
  }

  return 0;
}
```

처음에 짠 코드는 위와 같은데 두 번째 케이스 ([10, 50, 5, 1])에선 undefined가 나서 찾아봤더니 조건문도 신기하고 for문의 조건문도 신기했습니당..
